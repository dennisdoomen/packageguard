[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("PackageGuard.Specs")]
namespace PackageGuard.Core
{
    public class AllowList : PackageGuard.Core.PackagePolicy
    {
        public AllowList() { }
        public System.Collections.Generic.List<string> Feeds { get; set; }
        public bool Prerelease { get; set; }
    }
    public class AnalyzerSettings
    {
        public AnalyzerSettings() { }
        public string CacheFilePath { get; init; }
        public bool ForceRestore { get; init; }
        public bool InteractiveRestore { get; init; }
        public string? NpmExePatch { get; init; }
        public PackageGuard.Core.NpmPackageManager? NpmPackageManager { get; set; }
        public bool ScanNuGet { get; init; }
        public bool SkipRestore { get; init; }
        public bool UseCaching { get; init; }
    }
    public class DenyList : PackageGuard.Core.PackagePolicy
    {
        public DenyList() { }
        public bool Prerelease { get; set; }
    }
    public delegate PackageGuard.Core.ProjectPolicy GetPolicyByProject(string projectPath);
    public sealed class LicenseFetcher
    {
        public LicenseFetcher(Microsoft.Extensions.Logging.ILogger logger, string? gitHubApiKey = null) { }
        public System.Threading.Tasks.Task AmendWithMissingLicenseInformation(PackageGuard.Core.PackageInfo package) { }
    }
    public enum NpmPackageManager
    {
        None = 0,
        Npm = 1,
        Yarn = 2,
        Pnpm = 3,
    }
    [MemoryPack.MemoryPackable(MemoryPack.GenerateType.Object)]
    public class PackageInfo : MemoryPack.IMemoryPackFormatterRegister, MemoryPack.IMemoryPackable<PackageGuard.Core.PackageInfo>
    {
        public PackageInfo() { }
        [MemoryPack.MemoryPackIgnore]
        public bool IsUsed { get; set; }
        public string? License { get; set; }
        public string? LicenseUrl { get; set; }
        public string Name { get; set; }
        public string[] Projects { get; set; }
        public string? RepositoryUrl { get; set; }
        public string Source { get; set; }
        public string SourceUrl { get; set; }
        public string Version { get; set; }
        public void MarkAsUsed() { }
        public bool MatchesFeed(string feedWildcard) { }
        public bool SatisfiesRange(string name, string? versionRange = null) { }
        public override string ToString() { }
        public void TrackAsUsedInProject(string projectPath) { }
    }
    public class PackageInfoCollection : System.Collections.Generic.IEnumerable<PackageGuard.Core.PackageInfo>, System.Collections.IEnumerable
    {
        public PackageInfoCollection(Microsoft.Extensions.Logging.ILogger logger) { }
        public void Add(PackageGuard.Core.PackageInfo package) { }
        public void Clear() { }
        public PackageGuard.Core.PackageInfo? Find(string name, string version, NuGet.Protocol.Core.Types.SourceRepository[] projectNuGetSources) { }
        public System.Collections.Generic.IEnumerator<PackageGuard.Core.PackageInfo> GetEnumerator() { }
        public System.Threading.Tasks.Task TryInitializeFromCache(string cacheFilePath) { }
        public System.Threading.Tasks.Task WriteToCache(string cacheFilePath) { }
    }
    public abstract class PackagePolicy
    {
        protected PackagePolicy() { }
        public System.Collections.Generic.List<string> Licenses { get; set; }
        public System.Collections.Generic.List<PackageGuard.Core.PackageSelector> Packages { get; set; }
    }
    public class PackageSelector
    {
        public PackageSelector(string id) { }
        public PackageSelector(string id, string versionRange) { }
        public string Id { get; set; }
        public string? VersionRange { get; set; }
    }
    public class PolicyViolation : System.IEquatable<PackageGuard.Core.PolicyViolation>
    {
        public PolicyViolation(string PackageId, string Version, string License, string[] Projects, string FeedName, string FeedUrl) { }
        public string FeedName { get; init; }
        public string FeedUrl { get; init; }
        public string License { get; init; }
        public string PackageId { get; init; }
        public string[] Projects { get; init; }
        public string Version { get; init; }
    }
    public class ProjectAnalyzer
    {
        public ProjectAnalyzer(PackageGuard.Core.LicenseFetcher licenseFetcher) { }
        public Microsoft.Extensions.Logging.ILogger Logger { get; set; }
        public System.Threading.Tasks.Task<PackageGuard.Core.PolicyViolation[]> ExecuteAnalysis(string projectPath, PackageGuard.Core.AnalyzerSettings settings, PackageGuard.Core.GetPolicyByProject getPolicyByProject) { }
    }
    public class ProjectPolicy
    {
        public ProjectPolicy() { }
        public PackageGuard.Core.AllowList AllowList { get; set; }
        public PackageGuard.Core.DenyList DenyList { get; set; }
        public string[] IgnoredFeeds { get; set; }
        public void Validate() { }
    }
}
namespace PackageGuard.Core.CSharp
{
    public class CSharpProjectAnalysisStrategy
    {
        public CSharpProjectAnalysisStrategy(PackageGuard.Core.GetPolicyByProject getPolicyByProject, PackageGuard.Core.LicenseFetcher licenseFetcher, Microsoft.Extensions.Logging.ILogger? logger) { }
        public System.Threading.Tasks.Task<PackageGuard.Core.PolicyViolation[]> ExecuteAnalysis(string projectOrSolutionPath, PackageGuard.Core.AnalyzerSettings settings, PackageGuard.Core.PackageInfoCollection packages) { }
    }
    public class CSharpProjectScanner
    {
        public CSharpProjectScanner(Microsoft.Extensions.Logging.ILogger logger) { }
        public System.Func<string[], string>? SelectSolution { get; set; }
        public System.Collections.Generic.List<string> FindProjects(string path) { }
    }
    public class DotNetLockFileLoader
    {
        public DotNetLockFileLoader() { }
        public bool ForceRestore { get; set; }
        public bool InteractiveRestore { get; set; }
        public Microsoft.Extensions.Logging.ILogger Logger { get; set; }
        public bool SkipRestore { get; set; }
        public NuGet.ProjectModel.LockFile? GetPackageLockFile(string path) { }
    }
    public class NuGetPackageAnalyzer
    {
        public NuGetPackageAnalyzer(Microsoft.Extensions.Logging.ILogger logger, PackageGuard.Core.LicenseFetcher licenseFetcher) { }
        public string[] IgnoredFeeds { get; set; }
        public bool InteractiveRestore { get; set; }
        public System.Threading.Tasks.Task CollectPackageMetadata(string projectPath, string packageName, NuGet.Versioning.NuGetVersion packageVersion, PackageGuard.Core.PackageInfoCollection packages) { }
    }
}
namespace PackageGuard.Core.CSharp.FetchingStrategies
{
    public class GitHubLicenseFetcher : PackageGuard.Core.CSharp.FetchingStrategies.IFetchLicense
    {
        public GitHubLicenseFetcher(string? gitHubApiKey) { }
        public System.Threading.Tasks.Task FetchLicenseAsync(PackageGuard.Core.PackageInfo package) { }
    }
    public interface IFetchLicense
    {
        System.Threading.Tasks.Task FetchLicenseAsync(PackageGuard.Core.PackageInfo package);
    }
    public class UrlLicenseFetcher : PackageGuard.Core.CSharp.FetchingStrategies.IFetchLicense
    {
        public UrlLicenseFetcher(Microsoft.Extensions.Logging.ILogger logger) { }
        public System.Threading.Tasks.Task FetchLicenseAsync(PackageGuard.Core.PackageInfo package) { }
    }
}
namespace PackageGuard.Core.Npm
{
    public class NpmProjectAnalysisStrategy
    {
        public NpmProjectAnalysisStrategy(PackageGuard.Core.GetPolicyByProject policyByProject, Microsoft.Extensions.Logging.ILogger logger) { }
        public System.Threading.Tasks.Task<PackageGuard.Core.PolicyViolation[]> ExecuteAnalysis(string projectOrSolutionPath, PackageGuard.Core.AnalyzerSettings settings, PackageGuard.Core.PackageInfoCollection packages) { }
    }
    public class NpmRegistryMetadataFetcher
    {
        public NpmRegistryMetadataFetcher(Microsoft.Extensions.Logging.ILogger logger) { }
        public System.Threading.Tasks.Task FetchMetadataAsync(PackageGuard.Core.PackageInfo package) { }
    }
}